/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace GraviolaWell {
  export type RarityGroupSettingStruct = {
    omega: BigNumberish;
    groupProbabilities: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ];
  };

  export type RarityGroupSettingStructOutput = [
    omega: bigint,
    groupProbabilities: [bigint, bigint, bigint, bigint, bigint]
  ] & {
    omega: bigint;
    groupProbabilities: [bigint, bigint, bigint, bigint, bigint];
  };

  export type WordStruct = {
    keyword: string;
    lowerRange: BigNumberish;
    upperRange: BigNumberish;
  };

  export type WordStructOutput = [
    keyword: string,
    lowerRange: bigint,
    upperRange: bigint
  ] & { keyword: string; lowerRange: bigint; upperRange: bigint };

  export type RarityGroupStruct = {
    name: string;
    rarityPerc: BigNumberish;
    keywords: GraviolaWell.WordStruct[];
  };

  export type RarityGroupStructOutput = [
    name: string,
    rarityPerc: bigint,
    keywords: GraviolaWell.WordStructOutput[]
  ] & {
    name: string;
    rarityPerc: bigint;
    keywords: GraviolaWell.WordStructOutput[];
  };
}

export declare namespace GraviolaMetadata {
  export type MetadataStruct = {
    image: string;
    prompt: string;
    rarity: BigNumberish;
    filled: boolean;
  };

  export type MetadataStructOutput = [
    image: string,
    prompt: string,
    rarity: bigint,
    filled: boolean
  ] & { image: string; prompt: string; rarity: bigint; filled: boolean };
}

export interface GraviolaInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "KEYWORDS_PER_TOKEN"
      | "RARITY_GROUPS_LENGTH"
      | "TOKENS_PER_TRADE_UP"
      | "_tradeUp"
      | "aiOracle"
      | "aiOracleCallback"
      | "approve"
      | "balanceOf"
      | "estimateFee"
      | "findRarityGroupRange"
      | "findWordFromRand"
      | "getApproved"
      | "getMetadata"
      | "getRarityGroups"
      | "getTokenRarities"
      | "getWordProbability"
      | "isApprovedForAll"
      | "isFinalized"
      | "mint"
      | "name"
      | "ownedTokens"
      | "ownerOf"
      | "rollWords(uint256)"
      | "rollWords(uint256,(uint256,uint256[5]))"
      | "safeTransferFrom(address,address,uint256)"
      | "safeTransferFrom(address,address,uint256,bytes)"
      | "setApprovalForAll"
      | "supportsInterface"
      | "symbol"
      | "tokenURI"
      | "totalSupply"
      | "tradeUp"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Approval"
      | "ApprovalForAll"
      | "Mint"
      | "PromptRequest"
      | "PromptResponse"
      | "RollResult"
      | "TokenReady"
      | "Transfer"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "KEYWORDS_PER_TOKEN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RARITY_GROUPS_LENGTH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOKENS_PER_TRADE_UP",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_tradeUp",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "aiOracle", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "aiOracleCallback",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "findRarityGroupRange",
    values: [BigNumberish, GraviolaWell.RarityGroupSettingStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "findWordFromRand",
    values: [BigNumberish, GraviolaWell.RarityGroupStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetadata",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRarityGroups",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenRarities",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getWordProbability",
    values: [BigNumberish, GraviolaWell.RarityGroupStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isFinalized",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "mint", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownedTokens",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "ownerOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rollWords(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rollWords(uint256,(uint256,uint256[5]))",
    values: [BigNumberish, GraviolaWell.RarityGroupSettingStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenURI",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tradeUp",
    values: [[BigNumberish, BigNumberish, BigNumberish]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "KEYWORDS_PER_TOKEN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RARITY_GROUPS_LENGTH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOKENS_PER_TRADE_UP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_tradeUp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "aiOracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "aiOracleCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "estimateFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findRarityGroupRange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findWordFromRand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRarityGroups",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenRarities",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWordProbability",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isFinalized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ownedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rollWords(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollWords(uint256,(uint256,uint256[5]))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tradeUp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [owner: string, approved: string, tokenId: bigint];
  export interface OutputObject {
    owner: string;
    approved: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    owner: AddressLike,
    operator: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    owner: string,
    operator: string,
    approved: boolean
  ];
  export interface OutputObject {
    owner: string;
    operator: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MintEvent {
  export type InputTuple = [addr: AddressLike, tokenId: BigNumberish];
  export type OutputTuple = [addr: string, tokenId: bigint];
  export interface OutputObject {
    addr: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PromptRequestEvent {
  export type InputTuple = [
    tokenId: BigNumberish,
    keywords: string,
    rarity: BigNumberish
  ];
  export type OutputTuple = [tokenId: bigint, keywords: string, rarity: bigint];
  export interface OutputObject {
    tokenId: bigint;
    keywords: string;
    rarity: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PromptResponseEvent {
  export type InputTuple = [input: string, output: string];
  export type OutputTuple = [input: string, output: string];
  export interface OutputObject {
    input: string;
    output: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RollResultEvent {
  export type InputTuple = [result: string, rarityPerc: BigNumberish];
  export type OutputTuple = [result: string, rarityPerc: bigint];
  export interface OutputObject {
    result: string;
    rarityPerc: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenReadyEvent {
  export type InputTuple = [addr: AddressLike, tokenId: BigNumberish];
  export type OutputTuple = [addr: string, tokenId: bigint];
  export interface OutputObject {
    addr: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, tokenId: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Graviola extends BaseContract {
  connect(runner?: ContractRunner | null): Graviola;
  waitForDeployment(): Promise<this>;

  interface: GraviolaInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  KEYWORDS_PER_TOKEN: TypedContractMethod<[], [bigint], "view">;

  RARITY_GROUPS_LENGTH: TypedContractMethod<[], [bigint], "view">;

  TOKENS_PER_TRADE_UP: TypedContractMethod<[], [bigint], "view">;

  _tradeUp: TypedContractMethod<
    [
      _seed: BigNumberish,
      _tradeUpComponentsGroupId: BigNumberish,
      _averageTokenRarity: BigNumberish
    ],
    [[string, bigint, bigint]],
    "view"
  >;

  aiOracle: TypedContractMethod<[], [string], "view">;

  aiOracleCallback: TypedContractMethod<
    [requestId: BigNumberish, output: BytesLike, callbackData: BytesLike],
    [void],
    "nonpayable"
  >;

  approve: TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[owner: AddressLike], [bigint], "view">;

  estimateFee: TypedContractMethod<[], [bigint], "view">;

  findRarityGroupRange: TypedContractMethod<
    [
      _percInput: BigNumberish,
      _raritySetting: GraviolaWell.RarityGroupSettingStruct
    ],
    [[GraviolaWell.RarityGroupStructOutput, bigint]],
    "view"
  >;

  findWordFromRand: TypedContractMethod<
    [_randNum: BigNumberish, _targetGroup: GraviolaWell.RarityGroupStruct],
    [bigint],
    "view"
  >;

  getApproved: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  getMetadata: TypedContractMethod<
    [tokenId: BigNumberish],
    [GraviolaMetadata.MetadataStructOutput],
    "view"
  >;

  getRarityGroups: TypedContractMethod<
    [],
    [
      [
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput
      ]
    ],
    "view"
  >;

  getTokenRarities: TypedContractMethod<
    [tokenId0: BigNumberish, tokenId1: BigNumberish, tokenId2: BigNumberish],
    [
      [[bigint, bigint, bigint], bigint] & {
        rarities: [bigint, bigint, bigint];
        average: bigint;
      }
    ],
    "view"
  >;

  getWordProbability: TypedContractMethod<
    [_keywordIndex: BigNumberish, _targetGroup: GraviolaWell.RarityGroupStruct],
    [bigint],
    "view"
  >;

  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;

  isFinalized: TypedContractMethod<
    [requestId: BigNumberish],
    [boolean],
    "view"
  >;

  mint: TypedContractMethod<[], [void], "payable">;

  name: TypedContractMethod<[], [string], "view">;

  ownedTokens: TypedContractMethod<[addr: AddressLike], [bigint[]], "view">;

  ownerOf: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  "rollWords(uint256)": TypedContractMethod<
    [_seed: BigNumberish],
    [[string, bigint, bigint]],
    "view"
  >;

  "rollWords(uint256,(uint256,uint256[5]))": TypedContractMethod<
    [
      _seed: BigNumberish,
      _customRaritySetting: GraviolaWell.RarityGroupSettingStruct
    ],
    [[string, bigint, bigint]],
    "view"
  >;

  "safeTransferFrom(address,address,uint256)": TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  "safeTransferFrom(address,address,uint256,bytes)": TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  symbol: TypedContractMethod<[], [string], "view">;

  tokenURI: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  tradeUp: TypedContractMethod<
    [_tradeUpTokenIds: [BigNumberish, BigNumberish, BigNumberish]],
    [void],
    "payable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "KEYWORDS_PER_TOKEN"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "RARITY_GROUPS_LENGTH"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "TOKENS_PER_TRADE_UP"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_tradeUp"
  ): TypedContractMethod<
    [
      _seed: BigNumberish,
      _tradeUpComponentsGroupId: BigNumberish,
      _averageTokenRarity: BigNumberish
    ],
    [[string, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "aiOracle"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "aiOracleCallback"
  ): TypedContractMethod<
    [requestId: BigNumberish, output: BytesLike, callbackData: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[owner: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "estimateFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "findRarityGroupRange"
  ): TypedContractMethod<
    [
      _percInput: BigNumberish,
      _raritySetting: GraviolaWell.RarityGroupSettingStruct
    ],
    [[GraviolaWell.RarityGroupStructOutput, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "findWordFromRand"
  ): TypedContractMethod<
    [_randNum: BigNumberish, _targetGroup: GraviolaWell.RarityGroupStruct],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getApproved"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getMetadata"
  ): TypedContractMethod<
    [tokenId: BigNumberish],
    [GraviolaMetadata.MetadataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRarityGroups"
  ): TypedContractMethod<
    [],
    [
      [
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput,
        GraviolaWell.RarityGroupStructOutput
      ]
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTokenRarities"
  ): TypedContractMethod<
    [tokenId0: BigNumberish, tokenId1: BigNumberish, tokenId2: BigNumberish],
    [
      [[bigint, bigint, bigint], bigint] & {
        rarities: [bigint, bigint, bigint];
        average: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getWordProbability"
  ): TypedContractMethod<
    [_keywordIndex: BigNumberish, _targetGroup: GraviolaWell.RarityGroupStruct],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "isFinalized"
  ): TypedContractMethod<[requestId: BigNumberish], [boolean], "view">;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<[], [void], "payable">;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "ownedTokens"
  ): TypedContractMethod<[addr: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "ownerOf"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "rollWords(uint256)"
  ): TypedContractMethod<
    [_seed: BigNumberish],
    [[string, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "rollWords(uint256,(uint256,uint256[5]))"
  ): TypedContractMethod<
    [
      _seed: BigNumberish,
      _customRaritySetting: GraviolaWell.RarityGroupSettingStruct
    ],
    [[string, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256)"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256,bytes)"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenURI"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "tradeUp"
  ): TypedContractMethod<
    [_tradeUpTokenIds: [BigNumberish, BigNumberish, BigNumberish]],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "Mint"
  ): TypedContractEvent<
    MintEvent.InputTuple,
    MintEvent.OutputTuple,
    MintEvent.OutputObject
  >;
  getEvent(
    key: "PromptRequest"
  ): TypedContractEvent<
    PromptRequestEvent.InputTuple,
    PromptRequestEvent.OutputTuple,
    PromptRequestEvent.OutputObject
  >;
  getEvent(
    key: "PromptResponse"
  ): TypedContractEvent<
    PromptResponseEvent.InputTuple,
    PromptResponseEvent.OutputTuple,
    PromptResponseEvent.OutputObject
  >;
  getEvent(
    key: "RollResult"
  ): TypedContractEvent<
    RollResultEvent.InputTuple,
    RollResultEvent.OutputTuple,
    RollResultEvent.OutputObject
  >;
  getEvent(
    key: "TokenReady"
  ): TypedContractEvent<
    TokenReadyEvent.InputTuple,
    TokenReadyEvent.OutputTuple,
    TokenReadyEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "Mint(address,uint256)": TypedContractEvent<
      MintEvent.InputTuple,
      MintEvent.OutputTuple,
      MintEvent.OutputObject
    >;
    Mint: TypedContractEvent<
      MintEvent.InputTuple,
      MintEvent.OutputTuple,
      MintEvent.OutputObject
    >;

    "PromptRequest(uint256,string,uint256)": TypedContractEvent<
      PromptRequestEvent.InputTuple,
      PromptRequestEvent.OutputTuple,
      PromptRequestEvent.OutputObject
    >;
    PromptRequest: TypedContractEvent<
      PromptRequestEvent.InputTuple,
      PromptRequestEvent.OutputTuple,
      PromptRequestEvent.OutputObject
    >;

    "PromptResponse(string,string)": TypedContractEvent<
      PromptResponseEvent.InputTuple,
      PromptResponseEvent.OutputTuple,
      PromptResponseEvent.OutputObject
    >;
    PromptResponse: TypedContractEvent<
      PromptResponseEvent.InputTuple,
      PromptResponseEvent.OutputTuple,
      PromptResponseEvent.OutputObject
    >;

    "RollResult(string,uint256)": TypedContractEvent<
      RollResultEvent.InputTuple,
      RollResultEvent.OutputTuple,
      RollResultEvent.OutputObject
    >;
    RollResult: TypedContractEvent<
      RollResultEvent.InputTuple,
      RollResultEvent.OutputTuple,
      RollResultEvent.OutputObject
    >;

    "TokenReady(address,uint256)": TypedContractEvent<
      TokenReadyEvent.InputTuple,
      TokenReadyEvent.OutputTuple,
      TokenReadyEvent.OutputObject
    >;
    TokenReady: TypedContractEvent<
      TokenReadyEvent.InputTuple,
      TokenReadyEvent.OutputTuple,
      TokenReadyEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
